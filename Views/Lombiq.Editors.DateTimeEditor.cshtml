@using Lombiq.ContentEditors.ViewModels
@using Lombiq.ContentEditors.Constants
@using Orchard.Localization.Services
@using Orchard.Localization.Models
@using Piedone.HelpfulLibraries.Utilities

@{
    var viewModel = Model.ViewModel as DateTimeEditorViewModel;

    @* Resources *@
    var isDateEditor = viewModel.EditorType == DateTimeEditorType.Date || viewModel.EditorType == DateTimeEditorType.DateWithTime;

    Script.Require(ResourceNames.Lombiq_Editors_DateTimeEditor).AtHead();

    if (isDateEditor)
    {
        Style.Require(ResourceNames.Lombiq_Editors_DateTimeEditor);
    }

    var backEndDisplayFormat = isDateEditor ? viewModel.BackEndDateDisplayFormat : viewModel.BackEndTimeDisplayFormat;
    var frontEndDisplayFormat = isDateEditor ? viewModel.FrontEndDateDisplayFormat : viewModel.FrontEndTimeDisplayFormat;
    var frontEndStoreFormat = isDateEditor ? viewModel.FrontEndDateStoreFormat : viewModel.FrontEndTimeStoreFormat;

    @* BEM *@
    const string DefaultBlockName = "dateTimeEditor";
    string BlockName = viewModel.BlockName ?? DefaultBlockName;

    @* Label init *@
    var labelAttributes = new Dictionary<string, object>();
    var hasLabel = !string.IsNullOrEmpty(viewModel.Label);
    if (hasLabel)
    {
        labelAttributes["class"] = $"editorLabel {DefaultBlockName}__label";

        if (viewModel.Required)
        {
            labelAttributes["class"] += " required";
        }

        if (!string.IsNullOrEmpty(viewModel.Tooltip))
        {
            labelAttributes["class"] += " hasTooltip";
        }
    }

    @* Picker init *@
    var editorType = isDateEditor ? "datePicker" : "timePicker";
    var inputType = isDateEditor ? "text" : "time";
    var inputId = viewModel.Name.Replace('.', '_');
    var pickerId = inputId + "_Picker";
    var pickerClassifiedName = Html.ClassifiedName(pickerId);

    var pickerElementAttributes = viewModel.BuildAttributes(new Dictionary<string, object>
    {
        { "type", inputType },
        { "id", pickerId },
        { "class", $"form-control {editorType} {DefaultBlockName}__{editorType} {pickerClassifiedName}" },
        { "autocomplete", "off" }
    });

    if (viewModel.Minimum.HasValue)
    {
        pickerElementAttributes.Add("min", viewModel.Minimum.Value.ToString(backEndDisplayFormat));
    }
    if (viewModel.Maximum.HasValue)
    {
        pickerElementAttributes.Add("max", viewModel.Maximum.Value.ToString(backEndDisplayFormat));
    }

    if (viewModel.Required)
    {
        pickerElementAttributes["required"] = true;
        pickerElementAttributes["class"] = pickerElementAttributes["class"] + " required";
    }

    if (!string.IsNullOrEmpty(viewModel.Placeholder))
    {
        pickerElementAttributes["placeholder"] = viewModel.Placeholder;
    }

    @* Localization *@
    var dateLocalizationServices = WorkContext.Resolve<IDateLocalizationServices>();
    var options = viewModel.LocalizationOptions ?? new DateLocalizationOptions
    {
        EnableTimeZoneConversion = viewModel.EditorType == DateTimeEditorType.Time || viewModel.EditorType == DateTimeEditorType.DateWithTime,
        EnableCalendarConversion = viewModel.EditorType == DateTimeEditorType.Date || viewModel.EditorType == DateTimeEditorType.DateWithTime,
        IgnoreDate = viewModel.EditorType == DateTimeEditorType.Time
    };

    DateTime? value;
    if (viewModel.Value is string)
    {
        DateTime.TryParse(viewModel.Value as string, out var parsedValue);
        value = parsedValue;
    }
    else
    {
        value = viewModel.Value as DateTime?;
    }
    
    var valueString = value.HasValue && value.Value != default(DateTime) ?
        dateLocalizationServices.ConvertToLocalizedString(value, backEndDisplayFormat, options) :
        "";

    @* Picker element *@
    pickerElementAttributes["value"] = valueString;

    var datePickerElement = new TagBuilder("input");
    foreach (var attribute in pickerElementAttributes)
    {
        if (attribute.Value != null)
        {
            datePickerElement.Attributes.Add(attribute.Key, attribute.Value.ToString());
        }
    }
}

<div class="editor editorField @DefaultBlockName @BlockName">
    @if (hasLabel)
    {
        @Html.Label(viewModel.Name, viewModel.Label, labelAttributes)
    }

    @Display.Lombiq_Tooltip(Text: viewModel.Tooltip)

    @if (!string.IsNullOrEmpty(viewModel.Hint))
    {
        <span class="@(DefaultBlockName)__hint">@(new HtmlString(viewModel.Hint))</span>
    }

    <div class="@(DefaultBlockName)__dateTimePickerContainer">
        @Html.Raw(datePickerElement.ToString(TagRenderMode.SelfClosing))
        @Html.Hidden(viewModel.Name)
    </div>
</div>

<script type="text/javascript">
    ; (function ($) {
        $(function () {
            $("#@pickerId").lombiq_Editors_DateTimeEditor({
                isDateEditor: @isDateEditor.ToString().ToLower(),
                inputElementSelector: "#@inputId",
                displayFormat: "@frontEndDisplayFormat",
                storeFormat: "@frontEndStoreFormat",
                errorMessages: {
                    invalidFormatErrorText: "@HttpUtility.JavaScriptStringEncode(T("Invalid value format given. Expected format: {0}", frontEndDisplayFormat).Text)",
                    valueIsHigherThanMaximumText: "@HttpUtility.JavaScriptStringEncode(T("The given value is higher than the maximum allowed.").Text)",
                    valueIsLowerThanMinimumText: "@HttpUtility.JavaScriptStringEncode(T("The given value is lower than the minimum allowed.").Text)",
                }
            });

            $(".ui-datepicker").hide();
        });
    })(jQuery);
</script>