@using Lombiq.ContentEditors.ViewModels
@using Lombiq.ContentEditors.Constants
@using Orchard.Localization.Services
@using Orchard.Localization.Models
@using Piedone.HelpfulLibraries.Utilities

@{
    var viewModel = Model.ViewModel as DateTimeEditorViewModel;

    @* Resources *@
    var isDateEditor = viewModel.EditorType == DateTimeEditorType.Date ||
        viewModel.EditorType == DateTimeEditorType.DateWithTimeZoneConversion;
    var isTimeEditor = viewModel.EditorType == DateTimeEditorType.Time ||
        viewModel.EditorType == DateTimeEditorType.TimeWithTimeZoneConversion;

    if (isDateEditor)
    {
        Script.Require(ResourceNames.Lombiq_Editors_DateTimeEditor).AtHead();
        Style.Require(ResourceNames.Lombiq_Editors_DateTimeEditor);
    }
    else if (isTimeEditor)
    {
        Script.Require(ResourceNames.jQueryTimeEntry).AtHead();
    }

    @* BEM *@
    const string DefaultBlockName = "dateTimeEditor";
    string BlockName = viewModel.BlockName ?? DefaultBlockName;

    const string TooltipElementName = DefaultBlockName + "__tooltip";

    @* Label init *@
    var labelAttributes = new Dictionary<string, object>();
    var hasLabel = !string.IsNullOrEmpty(viewModel.Label);
    if (hasLabel)
    {
        labelAttributes["class"] = $"editorLabel {DefaultBlockName}__label";

        if (viewModel.Required)
        {
            labelAttributes["class"] = labelAttributes["class"] + " required";
        }
    }

    @* Hint init *@
    var hasHint = !string.IsNullOrEmpty(viewModel.Hint);

    @* Picker init *@
    var editorType = isDateEditor ? "datePicker" : "timePicker";
    var inputId = viewModel.Name.Replace('.', '_');
    var pickerId = inputId + "_Picker";
    var pickerClassifiedName = Html.ClassifiedName(pickerId);

    var pickerElementAttributes = viewModel.BuildAttributes(new Dictionary<string, object>
    {
        { "type", editorType },
        { "id", pickerId },
        { "class", $"form-control {editorType} {DefaultBlockName}__{editorType} {pickerClassifiedName}" }
    });

    if (viewModel.Minimum.HasValue)
    {
        pickerElementAttributes.Add("min", viewModel.Minimum.Value.ToString(viewModel.DateFormat));
    }
    if (viewModel.Maximum.HasValue)
    {
        pickerElementAttributes.Add("max", viewModel.Maximum.Value.ToString(viewModel.DateFormat));
    }

    if (viewModel.Required)
    {
        pickerElementAttributes["required"] = true;
        pickerElementAttributes["class"] = pickerElementAttributes["class"] + " required";
    }

    if (!string.IsNullOrEmpty(viewModel.Placeholder))
    {
        pickerElementAttributes["placeholder"] = viewModel.Placeholder;
    }

    @* Localization *@
    var dateLocalizationServices = WorkContext.Resolve<IDateLocalizationServices>();
    var options = new DateLocalizationOptions
    {
        EnableTimeZoneConversion = viewModel.EditorType == DateTimeEditorType.Time ||
            viewModel.EditorType == DateTimeEditorType.DateWithTimeZoneConversion,
        EnableCalendarConversion = viewModel.EditorType == DateTimeEditorType.Date,
        IgnoreDate = viewModel.EditorType == DateTimeEditorType.Time
    };

    var frontEndDisplayFormat = isDateEditor ? viewModel.FrontEndDateDisplayFormat : "HH:mm";
    var frontEndStoreFormat = isDateEditor ? viewModel.FrontEndDateStoreFormat : "HH:mm";

    // Assume that the given value is a string and properly formatted.
    var dateTimeString = viewModel.Value as string;

    // If the value is not string then assume that it is a DateTime object. If so, format it.
    if (string.IsNullOrEmpty(dateTimeString) && viewModel.Value is DateTime?)
    {
        var value = viewModel.Value as DateTime?;
        dateTimeString = value.HasValue && value.Value != default(DateTime) ?
            viewModel.Value is string ?
                (string)viewModel.Value :
                dateLocalizationServices.ConvertToLocalizedString(value, viewModel.DateFormat, options) :
            "";
    }

    @* Picker element *@
    pickerElementAttributes["value"] = dateTimeString;

    var datePickerElement = new TagBuilder("input");
    foreach (var attribute in pickerElementAttributes)
    {
        if (attribute.Value != null)
        {
            datePickerElement.Attributes.Add(attribute.Key, attribute.Value.ToString());
        }
    }
}

<div class="editor editorField form-group @DefaultBlockName @BlockName">
    @if (hasLabel)
    {
        @Html.Label(viewModel.Name, viewModel.Label, labelAttributes)
    }

    @if (hasHint)
    {
        <span class="@TooltipElementName" title="@viewModel.Hint"></span>
    }

    <div class="@(DefaultBlockName + "__dateTimePickerContainer")">
        @Html.Raw(datePickerElement.ToString(TagRenderMode.SelfClosing))
        @Html.Hidden(viewModel.Name, dateTimeString)
    </div>
</div>

@if (hasHint && this.WasNotDisplayed("Lombiq.Editors.DateTimeEditor.Hint"))
{
    using (Script.Foot())
    {
        <script type="text/javascript">
            ; (function ($) {
                $(function () {
                    $(".@TooltipElementName").tooltip({
                        content: function () {
                            return $(this).prop("title");
                        },
                        classes: {
                            "ui-tooltip": "highlight"
                        }
                    });
                });
            })(jQuery);
        </script>
    }
}

<script type="text/javascript">
    ; (function ($) {
        $(function () {
            $("#@pickerId").lombiq_Editors_DateTimeEditor({
                inputElementSelector: "#@inputId",
                dateDisplayFormat: "@frontEndDisplayFormat",
                dateStoreFormat: "@frontEndStoreFormat",
                errorMessages: {
                    invalidDateFormatErrorText: "@HttpUtility.JavaScriptStringEncode(T("Invalid date format given. Expected format: {0}", frontEndDisplayFormat).Text)",
                    valueIsGreaterThanMaximumText: "@HttpUtility.JavaScriptStringEncode(T("The given date is greater than the maximum date enabled to this field.").Text)",
                    valueIsSmallerThanMinimumText: "@HttpUtility.JavaScriptStringEncode(T("The given date is smaller than the minimum date enabled to this field.").Text)",
                }
            });

            $(".ui-datepicker").hide();
        });
    })(jQuery);
</script>